不用using namespace std可以在cout前加std：：然后返回int值，但都不要忘了
include<string.h>不同于include<string>一般应该使用前者
int-2147483648~2147483647，unsigned int0~4294967295，
宏定义可以在函数内完成
宏定义可以定义数值或函数
#include<>或者“”后者用处大，可自定义自己的库文件(与源文件在同一文件夹下)
在预处理语句中用到的标识符只能来自预处理语句或者编译器
return可以返回有值标识符
if后加（）
定义数组时【】内是行列数量，而引用时【】中是行列序号（存在零），max为前者减一
全局数组内初始值为0，局部数组初始值任意
指针的特殊循环判断条件只要指针有指向即可，不一定有数值
int *l=&k[0][0]或者int *l=k（数组名称本身看做指针名称）
指针顺序为栈-1，数组为堆+1
用指针化简数组输出，省去循环嵌套
指针内可以用自加自减
输出字符串printf%s ，e；直接使用数组名即可
a97  A65，小写字母反而ASCII值更大
switch只是标记插入位置，但并不是满足case才可以执行
存在long long类型输入输出位%lld（没有三个long的）
%d表示十进制整形，可以直接通过%变换进制，%o为八进制，%d为十进制，%x为十六进制
二进制数字输入为0b.....，输出%d会自动转换
<stdlib>:itoa函数将数字转换为字符形式储存在字符数组中，itoa(数字，储存数组首地址，基数（常用来进制转换，范围2-36，不转换使用10即可）)
	gcvt(数，位数，数组首地址)（将浮点型数转换为字符串，取四舍五入） (位数较少用科学计数法，位数多了也不会多输出0)
	atof（将字符串转换成浮点型数）atoi（将字符串转换成整型数）atol() strtod(字符，终止字符（可为空即执行到底）)
1e2表示1*10的2次方,会自动转换成正常整形
c中存在-0
检验临界值，注意=有无
注意输出格式如：03
类型转换问题，式子中出现了的最高精度类型，其他类型回向这一类型隐性转化（但是只是在和它直接运算时候才进行转换，与它没关系的时候运算不会转换，可能会损失精度），所以要是式子中出现不小于所需精度的类型的值 例：double i=....要带小数点的。
调试声明处断点会被跳过，赋值处会停留，变蓝色为执行前；for、return都会自带断点，所以有时候靠输出更为方便
调试监听值吧不一定就是真正内存里的值
注意数组从【0】开始计数，寻找特定值时不要找错下标
合理利用相对“坐标”
栈思想：压栈
num[n++] = a;便于储存顺序数据
pow函数有坑，少用不要用
声明指针时值赋值也为指针变量值
数组本身既是一连串值，完全可以从中间取一个值把他以后的当做一个新数组
strcpy（目标数组地址，源数组地址）   与下面相比直接读到头儿了
strncpy(目标数组地址，源数组地址，最大长度（不越界那就是长度了）)  （可以用来搭配扫描进行字符串读取）
sscanf（字符串原地址，格式符，赋值给的地址）  相当于不是键盘输入而是直接由string扫描进来
strcat（首字符串，尾字符串），把后一个字符串连接到首字符串
strstr（原字符串地址，查询字符串地址）
vector头文件
sort（数组首地址，末地址+1，cmp），区间左开右闭，cmp是自定义bool型函数，直接返回对>（大到小）、<（小到大）的逻辑判断值0、1，自动将数组重新排列，默认从小到大，需要引入#include<algorithm>
此外algorithm头文件下还有swap（两个相同类型的变量，不要地址）,这形参与我们平常自定义的swap函数不同，函数reverse(数组地址一，数组地址二)将中间的值顺序翻转，next_permutation(开始地址，结尾地址)将期间的数字进行一次下一次的全排列，并且在排列完后如果已经排列完(即这次在排列就回到最初情况了)那么返回0（返回0也已经排列了）
以及fill（开始地址，结尾地址，填充量）将数组这部分量赋值成该填充量；max(量1，量2),min(量1，量2)返回较大（较小值）
strlen（首地址）
getchar（void）返回型与putchar（整形ASCII码） ，gets（字符串首地址）与puts（字符串首地址）
abs与fabs取绝对值区别：abs用于整形，fabs针对浮点型，也可用于整形
c语言字符串不可以用单引号
一般能用double用double，float存在计算精度问题
不存在unsigned double
计算机位数标识bit，不是字节byte
unsigned int 赋负值显示的是32位最大值-该值
sizeof返回数组长度时string型会自动加上\0的位置，多一个；当然也可以用来判断数据类型占用字节数
strlen输出不包含\0的长度，而sizeof是整个长度，包含\0
字符串数组赋值必须留出最后\0的位置，否则编译不过
c++用cout可以直接输出字符串数组
强制转换类型是一次性的，在此代码外并没有转换类型
for循环第一分号内的初值条件（声明和赋值都是）只在for循环内有效，并且一旦在for该位置赋值则相当于另立一个变量（与外面的没关系了），最终的值也传不到外面的同名变量
static空间不释放但是仍受到局部约束，不同于extern，extern类型不可用动态定义
记得每次输入清空缓存区防止干扰下次输入（尤其是gets存在时）
多次重复执行使用调用函数
逐字输入手动赋值字符串记得手动添加结束符
循环使用的函数最好定义数组时赋空值，以防内存未释放导致值继承
不要把循环变量i全局化，如果用到的时候就麻烦了
循环内分清时间时刻
for循环判断终态，进而判断自增次数，也就是循环体执行次数
控制此次数型循环，控制对应关系型循环（实在不行就另外定义一个变量实现次数标记功能）
它识别不出回车
两个输出之间没有自带回车
小心符号整形-0的存在
格式规范符五舍六入（并且0.51也入）



傻傻的错误：
别把判断i的语句块放到循环里面
for循环最后判断不满足的时候是已经自增后的了，eg：for (i=0;i<k;i++)会执行k次，赋值到a【i-1】i=k时停止，自增k次
改了上面看看下面受不受影响 eg：循环加数组
输入%d的double会成为零
赋值（如：输入）前对变量操作为无用功
用函数记得引用库
fix向零取整，floor向负无穷取整，ceil向正无穷取整，round四舍五入，保留位数自动四舍五入
算出double值却让函数返回整型值，失去精度了
pow返回浮点数类型，注意有些类型有的计算不可进行
goto语句灵活使用
循环变量嵌套到j了别思维定式使用i了
输入输出格式符要对应好
看好是int型还是double型	
struct变量声明记得struct 结构体名 变量名有个struct，如果用typedef就简单了直接像int一样就ok





思考：
想一下各种循环判断条件的自增判断位置问题
强制转换类型后增减会不会影响他本身的值
具体如何实现扫描任意输入内容中特定内容并输出
如何储存多次执行后的数据（尤其是储存字符串）